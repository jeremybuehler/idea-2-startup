'use client'

import React, { useMemo, useState, useCallback } from 'react'
import JSZip from 'jszip'

// Layout components
import { Header, Footer } from '@/components/layout'

// Section components
import {
  HeroSection,
  IdeaIntakeCard,
  DeliverablesSnapshot,
  WhyLaunchloom,
  PipelineResults,
  PricingSection,
  RoadmapSection,
  LeadCaptureSection
} from '@/components/sections'

// Modal components
import { DeployGuideModal } from '@/components/modals'

// Error Boundary
import { ErrorBoundary } from '@/components/ErrorBoundary'

// Types and utilities
import { Dossier } from '@/types'
import {
  scoreIdea,
  toSlug,
  nowISO,
  TemplateGenerator,
  ExportUtils
} from '@/lib/business-logic'

// ============================================================================
// ZIP Generation Helpers
// ============================================================================

function composeRepoZip(slug: string, dossier: Dossier | null): JSZip {
  const zip = new JSZip()
  const prd = dossier?.prd || `# PRD\n\nFill in details.`
  const agents = dossier?.runbook || `# agents.yaml\n`
  const pkg = `{"name":"${slug}","private":true,"version":"0.1.0","scripts":{"dev":"next dev","build":"next build","start":"next start","lint":"next lint"},"dependencies":{"next":"14.2.5","react":"18.2.0","react-dom":"18.2.0"},"devDependencies":{"@types/node":"20.11.30","@types/react":"18.2.66","@types/react-dom":"18.2.22","typescript":"5.4.5"}}`
  const nextConfig = `/** @type {import('next').NextConfig} */\nconst nextConfig = { reactStrictMode: true };\nmodule.exports = nextConfig;\n`
  const tsconfig = `{"compilerOptions":{"target":"ES2022","lib":["dom","dom.iterable","esnext"],"allowJs":true,"skipLibCheck":true,"strict":true,"forceConsistentCasingInFileNames":true,"noEmit":true,"esModuleInterop":true,"module":"esnext","moduleResolution":"bundler","resolveJsonModule":true,"isolatedModules":true,"jsx":"preserve","baseUrl":"."},"include":["next-env.d.ts","**/*.ts","**/*.tsx"],"exclude":["node_modules"]}`
  const indexPage = `import Head from 'next/head';\nimport { useState } from 'react';\nexport default function Home(){\n  const [idea, setIdea] = useState('');\n  return (\n    <main style={{fontFamily:'ui-sans-serif', padding:24, lineHeight:1.7}}>\n      <Head><title>${slug}</title></Head>\n      <h1 style={{fontSize:34, fontWeight:700}}>Launchloom Prototype</h1>\n      <p>Paste an idea, then wire this UI to your backend.</p>\n      <textarea value={idea} onChange={e=>setIdea(e.target.value)} rows={8} style={{width:'100%', padding:14, fontSize:16}} placeholder=\"Your idea here...\"/>\n      <div style={{marginTop:12, fontSize:13, opacity:.7}}>See docs/PRD.md and ops/agents.yaml in this repo.</div>\n    </main>\n  );\n}`
  const readme = `# ${slug}\n\nLaunchloom starter generated by Launchloom.\n\n## Quickstart\n\n\`\`\`bash\npnpm i # or npm i / yarn\npnpm dev\n\`\`\`\n\n## Deploy to Vercel\n1. Create a GitHub repo and push these files.\n2. Go to https://vercel.com/new and import the repo.\n3. Keep defaults. Deploy.\n\n## Optional backend (FastAPI)\n- Code in /server. Deploy on Fly.io/Render or behind an API Gateway.\n- Set NEXT_PUBLIC_API_BASE to your backend URL to enable live mode.\n`
  const envSample = `# Frontend\nNEXT_PUBLIC_API_BASE=\nNEXT_PUBLIC_USE_LIVE=false\n`

  // Frontend
  zip.file(`${slug}/package.json`, pkg)
  zip.file(`${slug}/next.config.js`, nextConfig)
  zip.file(`${slug}/tsconfig.json`, tsconfig)
  zip.file(`${slug}/pages/index.tsx`, indexPage)
  zip.file(`${slug}/public/README.txt`, 'Generated by Launchloom')
  // Docs & ops
  zip.file(`${slug}/docs/PRD.md`, prd)
  zip.file(`${slug}/ops/agents.yaml`, agents)
  zip.file(`${slug}/.env.example`, envSample)
  // Backend stub
  zip.file(`${slug}/server/main.py`, TemplateGenerator.makeAPISketch())
  zip.file(`${slug}/server/requirements.txt`, `fastapi\nuvicorn\npydantic\n`)
  // Meta
  zip.file(`${slug}/REPO_TREE.txt`, TemplateGenerator.makeRepoTree(slug))
  zip.file(`${slug}/README.md`, readme)

  return zip
}

async function buildRepoZip(slug: string, dossier: Dossier | null): Promise<void> {
  const zip = composeRepoZip(slug, dossier)
  const blob = await zip.generateAsync({ type: 'blob' })
  ExportUtils.downloadBlob(blob, `${slug}.zip`)
}

// ============================================================================
// Main Application Component
// ============================================================================

function LaunchloomAppContent() {
  // Form state
  const [idea, setIdea] = useState('')
  const [title, setTitle] = useState('Idea-to-Startup Studio')
  const [oneLiner, setOneLiner] = useState(
    'Speak an idea → get PRD, mockups, code scaffold, and agent runbook.'
  )

  // Pipeline state
  const [running, setRunning] = useState(false)
  const [progress, setProgress] = useState(0)
  const [dossier, setDossier] = useState<Dossier | null>(null)

  // Configuration state
  const [useLive, setUseLive] = useState(false)
  const [apiBase, setApiBase] = useState('')
  const [statusMsg, setStatusMsg] = useState<string | null>(null)

  // Modal state
  const [openDeployGuide, setOpenDeployGuide] = useState(false)

  // Computed values
  const scores = useMemo(() => scoreIdea(idea || oneLiner), [idea, oneLiner])
  const slug = useMemo(() => toSlug(title), [title])

  // Pipeline execution
  const generate = useCallback(async (): Promise<void> => {
    if (!idea.trim()) return
    setRunning(true)
    setProgress(0)
    setDossier(null)
    setStatusMsg(null)

    const timer = setInterval(
      () => setProgress((p) => Math.min(99, p + Math.random() * 12)),
      220
    )

    const finish = (artifacts: Dossier) => {
      clearInterval(timer)
      setProgress(100)
      setDossier(artifacts)
      setRunning(false)
    }

    try {
      if (useLive && apiBase) {
        const brief = { title, one_liner: oneLiner, idea_text: idea.trim() }
        const res = await fetch(`${apiBase.replace(/\/$/, '')}/ingest/idea`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(brief)
        })
        if (!res.ok) throw new Error(`Ingest failed: ${res.status}`)
        const { id } = await res.json()
        const r2 = await fetch(`${apiBase.replace(/\/$/, '')}/dossier/${id}`)
        if (!r2.ok) throw new Error(`Dossier failed: ${r2.status}`)
        const serverDossier = await r2.json()
        finish({
          id,
          created_at: nowISO(),
          idea_text: idea.trim(),
          title,
          one_liner: oneLiner,
          scores,
          prd: TemplateGenerator.makePRD(title, oneLiner, idea, scores),
          runbook: TemplateGenerator.makeRunbook(title),
          repo: TemplateGenerator.makeRepoTree(slug),
          api: TemplateGenerator.makeAPISketch(),
          server: serverDossier
        })
        return
      }
    } catch (e: unknown) {
      const errorMsg = e instanceof Error ? e.message : String(e)
      setStatusMsg(`Live mode failed — falling back to simulator. (${errorMsg})`)
    }

    // Simulated mode fallback
    setTimeout(() => {
      const prd = TemplateGenerator.makePRD(title, oneLiner, idea, scores)
      const runbook = TemplateGenerator.makeRunbook(title)
      const repo = TemplateGenerator.makeRepoTree(slug)
      const api = TemplateGenerator.makeAPISketch()
      const artifacts: Dossier = {
        id: `idea_${Math.random().toString(36).slice(2, 8)}`,
        created_at: nowISO(),
        idea_text: idea.trim(),
        title,
        one_liner: oneLiner,
        scores,
        prd,
        runbook,
        repo,
        api
      }
      finish(artifacts)
    }, 4200)
  }, [idea, title, oneLiner, useLive, apiBase, scores, slug])

  // Export handlers
  const downloadJSON = useCallback((): void => {
    if (!dossier) return
    const blob = new Blob([JSON.stringify(dossier, null, 2)], {
      type: 'application/json'
    })
    ExportUtils.downloadBlob(blob, `${slug}-dossier.json`)
  }, [dossier, slug])

  const downloadRepo = useCallback(async (): Promise<void> => {
    if (!dossier) return
    await buildRepoZip(slug, dossier)
  }, [dossier, slug])

  const addRepoToGitHub = useCallback(async (): Promise<void> => {
    if (!dossier) return
    try {
      await buildRepoZip(slug, dossier)
    } catch (e) {
      console.warn('ZIP failed; opening GitHub anyway', e)
    }
    const url = ExportUtils.buildGitHubNewRepoUrl(
      slug,
      oneLiner || 'Launchloom generated scaffold',
      'public'
    )
    window.open(url, '_blank', 'noopener,noreferrer')
  }, [dossier, slug, oneLiner])

  // Navigation handlers
  const scrollToRoadmap = useCallback(() => {
    const el = document.getElementById('roadmap')
    if (el) {
      el.scrollIntoView({ behavior: 'smooth' })
    } else {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' })
    }
  }, [])

  const scrollToWorkflow = useCallback(() => {
    window.scrollTo({ top: 900, behavior: 'smooth' })
  }, [])

  return (
    <div className="min-h-screen w-full bg-white text-slate-900 antialiased selection:bg-indigo-100 selection:text-indigo-900">
      <Header
        useLive={useLive}
        onUseLiveChange={setUseLive}
        apiBase={apiBase}
        onApiBaseChange={setApiBase}
        onDeployGuideClick={() => setOpenDeployGuide(true)}
        onRoadmapClick={scrollToRoadmap}
      />

      <main className="mx-auto max-w-6xl px-5 py-10 text-[15.5px] leading-7">
        {/* Hero + Idea Intake */}
        <section className="grid md:grid-cols-2 gap-8 items-center">
          <HeroSection
            onRequestConcierge={() => setOpenDeployGuide(true)}
            onExploreWorkflow={scrollToWorkflow}
          />
          <IdeaIntakeCard
            title={title}
            onTitleChange={setTitle}
            oneLiner={oneLiner}
            onOneLinerChange={setOneLiner}
            idea={idea}
            onIdeaChange={setIdea}
            scores={scores}
            running={running}
            useLive={useLive}
            apiBase={apiBase}
            dossier={dossier}
            statusMsg={statusMsg}
            onGenerate={generate}
            onDownloadJSON={downloadJSON}
            onDownloadRepo={downloadRepo}
            onAddToGitHub={addRepoToGitHub}
          />
        </section>

        <DeliverablesSnapshot />
        <WhyLaunchloom />
        <PipelineResults progress={progress} dossier={dossier} title={title} />
        <PricingSection />
        <RoadmapSection />
        <LeadCaptureSection />
        <Footer />
      </main>

      <DeployGuideModal
        open={openDeployGuide}
        onOpenChange={setOpenDeployGuide}
        slug={slug}
      />
    </div>
  )
}

// ============================================================================
// Exported Component with Error Boundary
// ============================================================================

export default function LaunchloomApp() {
  return (
    <ErrorBoundary>
      <LaunchloomAppContent />
    </ErrorBoundary>
  )
}
